# 함수의 개념

함수(Function)란 "특정한 목적의 작업을 수행하기 위해 독립적으로 작성된 코드의 묶음"으로 정의할 수 있습니다. \
함수는 서브루틴(subrouine) 또는 프로시저(procedure)라고도 불리고 객체지향 프로그래밍 언어에서는 클래스가 가지는 함수를 메소드(metohd)라고 합니다.

# 함수의 장점

함수는 다음과 같은 장점을 가지고 있어 모든 프로그래밍 언어에서 가장 중요한 요소입니다.

+ 복잡한 문제를 해결 가능한 작은 문제로 분해하고 분해된 작은 문제의 해결책을 함수로 처리하고 함수를 구조적으로 사용하여 복잡한 문제를 해결하게 됩니다.
+ 같은 코드를 반복적으로 작성해야하는 문제를 해결합니다. 함수로 만들어 사용하면 코드 작성의 중복을 최소화하고 프로그램의 크기를 줄일 수 있습니다. 또한 함수는 코드의 수정과 유지 보수를 용이하게 합니다.
+ 캡슐화(Capsulation)가 가능합니다. 함수의 내부 구현과 함수 외부와의 인터페이스를 구분하여 인터페이스가 정해지면 함수 내부 구현을 지속적으로 프로그래머의 실력 향상에 맞추어 진화시킬 수 있습니다. 이러한 특징 때문에 이미 만들어진 함수에 대해서 인터페이스의 모습만 알고 있으면 함수의 실제 구현 내용을 할지 못해도 함수의 기능을 이용할 수 있도록 합니다.

# 함수의 구분

C++에서 사용할 수 있는 함수는 크게 라이브러리(libray)함수와 사용자 정의 함수(user defined function)로 구분됩니다.

+ 라이브러리 함수: 라이브러리 함수는 컴파일러를 제작한 회사에서 제공하여 컴파일된 기계어 코드를 모아둔 파일을 라이브러리라고 합니다.
+ 사용자 정의 함수: 사용자가 필요에 따라 직접 만들어서 사용하는 함수로 라이브러리 함수에서 제공되지 않는 함수를 사용자가 목적에 맞게 직접 만들어서 사용할 수 있습니다.

# 함수와 관련한 작업

함수 정의, 함수 선언, 함수 호출이 있습니다.

+ 함수 정의(function definition): 함수의 기능을 수행하기 위한 코드를 작성하는 것입니다.
+ 함수 호출(function call): 정의된 함수의 기능을 실행하는 것으로 실행을 위해 필요한 입력 데이터를 전달하고 함수가 기능을 수생하고 결과를 반환하는 경우 반환 데이터의 처리를 고려하여야 합니다.
+ 함수 선언(function declaration): 함수가 어떤 형태인지를 알려주는 것(선언)입니다.

이들 세가지 작업은 컴파일러가 이해하고 해석해야 하므로 표현 규칙(문법이라고도 함)이 서로 다르게 규정됩니다.

# 함수 정의

함수를 정의할 때 따라야 할 표현 규칙은 다음과 같은 형태를 갖는다. 정의된 함수는 함수 헤더(function header) 와 함수 몸체(function body)로 이루어집니다. \
아래의 함수 정의에서 함수 헤더는 `반환 자료형`, `함수이름`, `(매개변수 목록)`에 해당되며 함수 몸체는 `중괄호{}`로 내부에 해당합니다. \
함수의 몸체에는 함수가 수행하는 기능을 구현하는데 필요한 프로그램 코드들이 들어갑니다. 함수 몸체는 실제적인 작업이 이루어지는 영역입니다. 함수 몸체에 작성된 코드는 `{`에서 시작하여 `return문장` 또는 `}`에 도달할 때까지 순차적으로 프로그램 명령어를 하나씩 실행합니다. 함수 몸체의 코드가 종료되면 함수를 호출한 곳으로 되돌아가 다음 프로그램 코드를 실행합니다.

<img src= https://user-images.githubusercontent.com/112116885/222925278-104ef244-8af4-4c8b-9b7d-68deebd6509e.png width="50%" height="50%" title="함수 정의" alt="함수 정의"></img>

+ 반환 자료형(return data type): 함수가 기능을 수행한 후 반환하는 데이터의 자료형을 명시, 이 자료형은 변수를 학습할 때 배웠던 자료형과 같은 개념입니다. 함수가 반환하는 데이터가 없을 때는 반환 자료형을 `void`로 명시합니다. 데이터의 값을 반환하기 위해서는 `return` 키워드를 사용하여 값을 반환하여야합니다. `return` 다음에 값, 변수, 수식이 올 수 있습니다.
+ 함수 이름(function name): 함수 이름은 사람을 구별할 때 사용하는 이름과 같이 여러 함수 중 특정 함수를 구별하는 식별자 중 한 요소입니다. C++에서는 함수의 구분은 함수 이름과 매개변수의 자료형,매개변수 목록 개수의 조합으로 합니다. 함수 이름은 파스칼 표기법을 사용하고, 함수의 기능을 암시하는 이름을 부여하는 것이 좋으며, 동사 또는 명사가 조합된 형태로 구성하는 것이 좋습니다.
+ 매개변수 목록(argements, parameter list): 매개 변수는 함수의 기능을 수행하는데 필요한 입력 데이터의 표현에 사용됩니다. 입력 데이터가 없는 경우 매개변수를 명시하지 않습니다. 매개 변수의 개수는 여러 개가 될 수 있으며 쉼표로 구분합니다. 함수 이름과 구분을 위해 카멜 표기법을 사용합니다.

## 입력 데이터와 반환 데이터 모두 없는 함수 예

화면에 "Hello!"만을 출력하는 함수를 만들어보려 합니다. 화면에 "Hello!"만을 출력하는 것이므로 함수에 입력 데이터가 필요 없으며 함수의 기능인 "Hello!"를 화면에 출력한 후 반환할 결과 값이 없습니다. \
함수의 이름은 PrintHello 로 하겠습니다. 입력 데이터도 없기 때문에 매개변수도 명시하지 않고 반환 데이터도 없기 때문에 반환 자료형은 void입니다.

함수 정의의 모습은 다음과 같습니다.
```
void PrintHello()
{
    std::cout << "Hello!" << std::endl;
}
```

함수 헤더:
```
void PrintHello()
```

함수 몸체:
```
{
    std::cout << "Hello!" << std::endl;
}
```

## 입력 데이터는 있고 반환 데이터는 없는 함수 예

위의 함수에서 bool형의 데이터를 하나 입력받고 입력받은 데이터의 상태에 따라 다른 문장을 화면에 출력하는 함수를 만들어보려 합니다. \
입력 데이터가 하나 있어야 하기 때문에 함수를 정의할 때 매개 변수가 하나 명시되어야 합니다. 구체적인 함수의 기능은 다음과 같습니다.

입력 데이터로 bool형의 데이터를 받는데 참(true)라면 "Hello!"를 출력하고 거짓(false)를 입력 받으면 "Bye!"를 화면에 출력하는 함수입니다.
```
void PrintHello(bool state)
{
    if (state)
    {
        std::cout << "Hello!" << std::endl;
    }
    else
    {
        std::cout << "Bye!" << std::endl;
    }
}
```

함수 헤더:
```
void PrintHello(bool state)
```

함수 몸체:
```
{
    if (state)
    {
        std::cout << "Hello!" << std::endl;
    }
    else
    {
        std::cout << "Bye!" << std::endl;
    }
}
```

## 입력 데이터와 반환 데이터 모두 있는 함수 예

두 개의 정수 합을 구하고 결과 값을 반환하는 함수를 만들어보려 합니다.\
매개 변수의 개수는 두 개이고, 자료형은 정수를 나타내는 자료형인 short, int, long 등으로 선언합니다. 두 개의 정수 합을 구한 후 결과 값을 반환하기 때문에 반환 자료형을 명시해야 합니다.

함수의 이름은 Sum 으로 하겠습니다. 매개변수 두 개를 받고, 반환 자료형을 매개 변수의 자료형과 같은 int로 하겠습니다.

```
int Sum(int a, int b)
{
    return a + b;
}
```

함수 헤더:
```
int Sum(int a, int b)
```

함수 몸체:
```
{
    return a + b;
}
```

## 입력 데이터는 없지만 반환 데이터는 있는 함수 예

1을 출력하고 1을 반환하는 함수를 만들어보려 합니다. \
입력 데이터가 필요 없으며 함수의 기능인 '1'을 화면에 출력한 후 1을 반환해야 하므로 반환 자료형을 명시해야 합니다. \
함수의 이름은 One 으로 하겠습니다. 입력 데이터가 없기 때문에 매개변수는 명시하지 않고 반환 데이터가 있기 때문에 반환 자료형은 int입니다.

```
int One()
{
    std::cout << '1' << std::endl;
    return 1;
}
```

# 함수 호출(function call)

함수의 기능을 실행시키는 것을 함수 호출(function call)이라고 합니다. 함수를 호출하려면 함수의 이름을 적고, 함수가 필요로 하는 입력 데이터가 있다면 데이터를 나열하면 됩니다. 함수 호출도 C++에서 하나의 명령문이기 때문에 문장의 끝에 세미콜론(;)을 붙입니다. 또한 함수가 반환 데이터가 있다면 반환데이터를 처리하는 기능이 필요합니다.

함수를 호출하게 되면 함수 호출문 다음 코드의 실행은 잠시 중지되고 호출된 함수의 몸체 내의 문장들이 순차적으로 실행된 후 함수의 실행이 종료되면 함수 호출문 다음 위치로 되돌아 옵니다.

즉, 10번 줄에 int 자료형 x, y가 초기화 되고 Sum함수를 호출합니다 매개변수로 x와 y의 값인 1, 5가 각각 a 와 b에 값이 복사되고 함수 몸체의 코드가 수행됩니다. return을 하기 전 a + b를 더한 값이 12번 줄에 반환되고 별다른 연산 없이 ;를 만나 13번줄로 이동합니다.
<img src= https://user-images.githubusercontent.com/112116885/224146076-2d8e74cd-e14b-488e-83ce-990cf820cd12.PNG width="50%" height="50%" title="함수 호출" alt="함수 호출"></img>

위와 같이 함수를 호출할 때 데이터 값을 매개변수에 전달하는 것을 "값에 의한 호출(call by value)"라고 하며, 데이터가 저장된 메모리 주소를 매개 변수에 전달하는 것은 "참조에 의한 호출(call by reference)"라고 합니다.

# 함수 선언

함수 선언은 컴파일러에게 프로그램에서 사용하고자 하는 사용자 정의 함수를 비롯하여 라이브러리 함수의 정보를 미리 알려주는 것입니다. 함수 선언은 함수의 헤더와 유사한 형태를 가지는데 헤더에 ;를 붙여 선언합니다.

미리 알려주어야 할 함수의 정보를 함수 원형(function prototype)혹은 전방 선언 (forward declaration)이라고 합니다. 전방선언을 사용하는 이유는 순환호출(cyclic calling)의 경우 서로의 함수를 함수 몸체에서 호출하는데 전방 선언이 없다면 다른 함수의 정보를 가지고있지 않아 컴파일이 되지 않는 문제를 해결할 수 있어 사용합니다.

다음은 위에서 정의한 함수의 원형입니다.
```
void PrintHello();
void PrintHello(bool state);
int Sum(int a, int b);
int One();
```

함수 선언은 컴파일러에게 미리 함수 원형에 대한 정보를 제공하여 함수 호출 시 함수의 반환형과 매개 변수의 자료형이 올바른 것인지 검사하도록 합니다. 컴파일러가 함수 호출 문장을 해석 및 검사 할 때 컴파일러가 함수의 원형을 기반으로 함수 호출문이 올바른지 검사 할 수 있기 때문에 함수 원형을 알려 주는 함수 선언이 함수 호출보다 먼저 이루어져야 합니다.

함수의 정의가 함수 선언의 의미를 동시에 가지고 있습니다.

# inline 함수(inline function)

C++에서 인라인 함수는 함수 앞에 `inline` 지시자를 붙인 경우로 컴파일러가 인라인 함수를 호출하는 곳에 함수 몸체(function body)를 포함시켜 컴파일을 합니다. 이렇게 하면 함수 호출에 따른 오버헤드를 피할 수 있습니다.

요즘의 컴파일러는 자동으로 판단하여 함수를 인라인화 시킵니다. 따라서 대부분의 경우 굳이 사용할 필요는 없습니다.

오버헤드란 프로그램의 실행흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때, 추가적으로 시간과 메모리, 자원이 사용되는 현상입니다. 특히 외부 함수를 사용할 때 나타나는데 함수를 사용하기 위해 스택메모리를 할당하며, 매개변수가 있다면 대입연산까지도 일어나는 등 많은 과정을 진행하게 됩니다. 이런 오버헤드를 줄이고자 매크로함수와 인라인함수를 사용해 최적화하기도 합니다. 

오버헤드를 줄이기 위해 매크로를 사용하기도 하지만 함수가 아니기 때문에 논리적 오류를 발생시킬 수 있고, 매개변수 형식을 지정할 수 없기 때문에 iline 함수를 사용합니다.

+ 장점
    + 실제 함수 호출보다 프로그램 실행 속도가 빠르다.
    + 함수 호출 인수와 함수 매개변수의 자료형 검사를 수행한다.
+ 단점
    + 크기가 크거나 복잡한 태스크를 수행하는 함수의 경우 함수 호출의 오버헤드가 함수의 실행 시간에 비교하여 크지 않다.
    + 프로그램에서 모든 함수 호출문이 함수 정의 코드로 대체하기 때문에 메모리 사용 측면에서 일반 함수보다 불리하다.

# 디폴트 매개변수(default argument)

함수 원형(function prototype)을 선언할 때 매개변수의 기본 값을 설정하는 것이 가능합니다. 기본 값을 설정하면 함수 호출을 할 때 인수를 생략할 수 있다는 장점을 가집니다. 즉 매개변수에 값이 전달되지 않는 경우 디폴트 값이 전달되도록 함수를 선언할 수 있습니다. 값을 전달하는 것은 컴파일러에 의해 처리됩니다.

함수 선언시 한 번만 지정합니다. 즉 선언 후 정의 할 경우 디폴트 매개변수를 사용할 수 없으므로 선언시에 지정해야합니다.

디폴트 매개변수를 지정한 함수 원형의 선언 형태는 다음과 같습니다.
```
반환 자료형 함수 이름(자료형 매개변수명 = 기본 값, 자료형 매개변수명 = 기본 값);
int Sum(int a = 1, int b = 5);
```

디폴트 매개변수는 일반 매개변수와 같이 선언해야 할 경우 일반 매개변수 다음에 선언해야 하는데 형태는 다음과 같습니다.
```
int Sum(int a, int b = 5);  // 컴파일 성공
int Sum(int a = 1, int b);  // 컴파일 에러 발생
```

디폴트 매개변수를 선언한 함수를 호출 할 때 함수의 매개변수 수보다 적은 매개변수를 전달하는 경우 가장 왼쪽의 매개변수부터 전달됩니다.

디폴트 매개변수를 선언한 함수 사용시 다음과 같은 형태로 호출할 수 있습니다.
```
Sum();          // a와 b는 기본 값이 전달 됩니다.
Sum(2);         // a는 2가 b는 기본 값이 전달 됩니다.
SUm(2, 3);      // a는 2가 b는 3이 전달 됩니다.
```

# 가변 인자(Variable argument)

말 그대로 고정되지 않은 매개변수를 말합니다. C언어의 frintf()함수처럼 정해지지 않은 개수의 매개변수를 받아야 할 때 사용합니다.

가변 인자는 아래와 같이 최소 1개 이상의 고정 인수가 있어야 하며 ... 은 파라미터 순서 상 가장 마지막 위치에 있어야 합니다.

```
void function(int args, ...)
int sum(int args, ...)
```

아래와 같이 사용할 수 있습니다.
```
function(1, 2, 3, 4, 5);
function(1);
function(1,2,3);
```

함수 내에서 가변 인자를 다루기 위해 사용하는 1개의 헤더 파일과 4가지의 매크로가 있습니다.

```
#include <cstdarg>

#define va_start    __crt_va_start
#define va_arg      __crt_va_arg
#define va_end      __crt_va_end
#define va_copy(destination, source) ((destination) = (source))
```

매크로|설명
---|---
va_start|매개변수 리스트를 접근할 수 있도록 함(매개변수 리스트를 초기화)
va_arg|매개변수 리스트의 다음 인자를 접근
va_end|매개변수 리스트의 순회를 종료(매개변수 리스트를 정리)
va_copy|매개변수 리스트를 복사
va_list|va_start, va_end, va_copy에서 필요한 정보를 보유하고 있으며, 가변 인자들을 가리키게 될 포인터입니다.

`va_start`매크로 함수는 다음과 같은 두 인자를 가집니다.

```
va_start(va_list ap, x);
```

`va_list 인스턴스(ap)`와 `고정 인수(x)`를 받습니다. 첫 번째 주소의 기준은 고정 인수인 `x`변수에 따라 달라지며 `x`의 다음 인자를 `va_list`가 가리키도록 초기화 합니다. \
`prev`는 래퍼런스(참조형 변수), 함수, 배열이 될 수 없습니다. \
`va_list`를 사용하기 전에 반드시 해당 매크로 함수를 통해 초기화해야 합니다.

아래 함수에서 `vlist`는 `args` 다음에 오는 첫 가변 인자를 가리킵니다.

```
void function(int args, ...)
{
    va_list vlist;
    va_start(vlist, args);
}
```

`va_arg`매크로는 `va_list`타입에 할당된 값과 자료형(타입)을 리턴한 후 va_list의 주소를 자료형의 크기만큼 뒤로 이동시켜 다음 값을 출력할 수 있습니다.

위 `function`함수의 `vlist`에 저장된 데이터의 자료형이 int라면 아래와 같이 적습니다.

```
va_arg(vlist, int);
```

`va_end`매크로는 입력 매개변수로 `valist`자료형의 변수를 받으며 변수를 초기화 전의 상태로 만듭니다.

다음 코드는 `vlist`를 초기화 전 상태로 만듭니다.

```
va_end(vlist);
```

`va_copy`매크로는 `va_list`자료형의 변수 두 개를 매개변수로 입력 받으며 두 번째 list에서 첫 번째 list로 복사합니다. \
`va_copy`의 첫 인자는 초기화 상태가 아니어도 됩니다.

다음의 코드는 `vlist2`에 저장된 값을 `vlist1`으로 복사합니다.

```
va_copy(vlist1, vlist2);
```

전달받은 매개변수의 개수를 반환하는 매크로는 정의되어 있지 않아 반복문을 사용하기 위해선 다음의 두 가지 방법을 고려할 수 있습니다.

+ 첫 번째 매개변수에 변수의 개수, 두 번째 매개변수부터는 가변 매개변수들을 전달합니다. (배열을 함수에 전달하는 방법과 비슷합니다.)
+ 마지막 매개변수에는 처리 데이터에 포함되지 않는 값(nullptr)을 넣어 전달되는 데이터의 끝을 나타내도록 합니다. (문자열의 끝에 나타내는 배열을 함수에 전달하는 방법과 비슷합니다.)

# 함수 중복(function overloading)

동일한 이름 공간에서 이름이 같은 함수를 둘 이상 정의할 수 있습니다. C와 달리 함수 이름, 매개 변수의 자료형, 매개 변수의 수에 따라 이루어집니다. 이러한 함수들을 중복된(overloaded) 함수라 하고 매개 변수의 자료형 또는 매개 변수의 수에 따라 함수가 의미는 같으나 다른 기능을 가집니다.

함수 오버로딩 개념은 매개 변수의 자료형과 개수가 다르면 같은 이름을 가진 함수를 여러 개 정의할 수 있도록 합니다. \ 
매개변수의 자료형과 개수가 기존에 정의된 함수와 달라야 하며 리턴 자료형은 함수를 구별하는데 사용되지 않습니다. 즉 리턴 자료형만 다른 두 개의 함수는 중복할 수 없습니다.

정수 두 개와 실 수 두개의 더하는 함수 Sum()를 다음과 같이 만들 수 있습니다.

```
int Sum(int a, int b);
double Sum(double a, double b);
```

두개의 `int`를 제공하면 `Sum(int a, int b)`를 호출합니다. 두개의 `double`를 제공하면 `Sum(double a, double b)`를 호출합니다.

같은 이름의 함수를 매개 변수가 없이 사용하려면 서로 다른 이름을 지정하거나 out참조 매개 변수를 전달하도록 하는게 좋습니다.
```
int getRandomInt();
double getRandomDouble();
void getRandomValue(int& out);
void getRandomValue(double& out);
```

함수 중복은 다형성의 한 예로 전역 함수와 클래스의 멤버 함수에 모두 적용이 됩니다.

함수 중복이 가능하기 위해서는 아래의 조건이 만족되어야 합니다.
+ 중복된 함수들의 이름이 동일한가.
+ 중복된 함수들은 매개 변수의 자료형 또는 개수가 다른가.

`typedef` 선언은 새로운 타입을 만드는 것이 아니므로 아래 함수의 두 선언은 동일한 함수로 간주됩니다.
```
typedef char* string;
void print(string value);
void print(char* value);    // Compile Error
```

오버로드(overload)된 함수를 호출하면 다음 세 가지 결과 중 하나가 발생합니다.
+ 일치하는 함수가 있다. (호출이 특정 오버로드된 함수로 해석됩니다.)
+ 일치하는 함수가 없다. (오버로드된 함수 중에 인수가 일치하는 함수가 없다.)
+ 모호한 함수가 있다. (하나 이상의 오버로드된 함수와 인수가 일치한다.)

오버로드된 함수가 호출되면 C++은 다음 프로세스를 통해 호출할 함수의 버전을 결정합니다.

```
void print(char* value);
void print(int value);

print(0);
```

0은 기술적으로 `print(char*)`와 일치할 수 있지만 `print(int)`와 정확하게 일치합니다.

정확히 일치하는 항목이 없으면 C++에선 승격(promotion)을 통해 일치하는 함수를 찾으려 합니다.
+ `char`, `unsigned char` 및 `short`가 `int`로 승격 됩니다.
+ `unsigned short`는 `int`의 크기에 따라 `int`또는 `unsigned int`로 승격 됩니다.
+ `float`은 `double`로 승격됩니다.
+ 열거형`(enum)`은 `int`로 승격됩니다.

```
void print(char* value);
void print(int value);

print(a);
```

위 함수의 경우 print(char)가 없으므로 `char` `'a'`는 `int`로 승격되고 `print(int)와 일치합니다.

승격(promotioon)이 불가능한 경우 C++은 표준 변환을 통해 일치하는 항목을 찾으려고 합니다.
+ 숫자 타입은 다른 숫자 타입으로 변환됩니다. (Ex. `int` -> `float`)
+ 열거형`(enum)`은 위에서 말한 숫자 공식과 같습니다. (Ex. `enum` -> `int` -> `float`)
+ 0은 포인터 타입 및 숫자 타입과 일치합니다. (Ex. `0` -> `char*` or `0` -> `float`)
+ 포인터는 void 포인터와 일치합니다.

```
struct Employee;
void print(float value);
void print(Employee value);

print('a')
```
이 경우 `print(char)` 및 `print(int)`가 없으므로 `'a'`는 `float`으로 변환되어 `print(float)`과 일치합니다.

C++은 사용자 정의 변환을 통해 일치하는 함수를 찾습니다. 클래스는 암시적으로 적용될 수 있는 다른 타입으로 변환을 정의할 수 있습니다. 예를 들어 클래스 X의 사용자 정의 변환을 `int`로 정의할 수 있습니다.
```
class X;

void print(float value);
void print(int value);

X value;
print(value);
```

모든 오버로드된 함수가 고유한 매개 변수를 가져야 하는 경우 호출이 둘 이상과 일치하면 컴파일 오류로 간주됩니다. 

```
void print(unsigned int value);
void print(float value);

print('a');
print(0);
print(3.14159);
```

`print('a')`의 경우 C++은 정확하게 일치하는 함수를 찾을 수 없습니다. `'a'`를 `int`로 승격시키려고 하지만 `print(int)`도 없습니다. 표준 변환을 하면 'a'는 `unsigned int`와 `float`으로 변환할 수 있습니다. 이 두 표준 변환으로 인해 모호한 일치가 발생합니다.

print(0)도 비슷합니다. `0`은 `int`이며, `print(int)`는 없습니다. 결국, 표준 변환으로 인해 모호한 일치가 발생합니다.

`print(3.14159)`와 같이 모든 리터럴 부동 소수점 값은 f접미사가 없으면 `double`이 됩니다. `3.14159`는 `dobule`이며 `print(double)`은 없습니다. 따라서 표준 변환을 통해 모호한 일치가 발생합니다.

이 문제를 해결하기 위한 방법이 3가지 있습니다.

+ 호출하려고 하는 타입의 매개 변수를 가지는 새로운 오버로드된 함수를 정의한다. 그러면 C++은 정확히 일치하는 함수를 찾을 수 있습니다.
+ 모호한 인수를 호출할 함수의 타입으로 명시적 형변환을 사용합니다. 예를 들어보겠습니다.
```
int x = 0;
print(static_cast<unsigned int>(x)); // print(unsigned int)를 호출할 것입니다.
```
+ 인수가 리터럴인 경우 리터럴 접미사를 사용해 리터럴이 올바른 타입으로 해석되도록 합니다.
```
print(0u); // print(unsigned int)를 호출할 것입니다.
```

인수가 여러 개인 경우 C++은 일치하는 규칙을 차례로 각 인수에 적용합니다. \
그러한 함수가 발견된 경우, 그 함수는 가장 일치하는 함수지만 그러한 함수를 찾을 수 없는 경우 호출은 모호함(또는 불일치)로 간주됩니다.

```
void func(char c, int x);
void func(char c, double x)
void func(char c, float x)

func('x', 4);
```

모든 함수는 첫 번째 인수와 정확히 일치합니다. 그리고 두 번째 인수는 `func(char, int)`와 정확히 일치하지만 다른 함수는 변환이 필요합니다. 그래서 `func(char, int)`가 가장 일치하는 함수가 되고, 호출됩니다.

# 함수 템플릿(function template)

함수를 만들어 낼때 함수의 기능은 명확하지만 자료형을 모호하게 두는 것입니다. \
처리하는 데이터의 자료형이 달라도 알고리즘이 같은 경우 자료형을 일반화시키고 자료형에 대해 알고리즘을 일반화 할 수 있습니다.
이처럼 템플릿을 사용해 프로그래밍하는 것을 일반화 프로그래밍(제네릭 프로그래밍:Generic Programming)이라고 합니다.

함수 정의 시작 부분에 `template <typename T>`를 추가합니다. `template <class T>`도 동일한 표현이지만 `typename`이 직관적입니다. \
`T`는 본인이 구분하기 쉬운 이름을 사용하면 됩니다. `template <typename SequenceContainer>`와 같이 직관적인 표현이 코드 문서화와 유지보수하는데 낫습니다.

`template <typename T1, typename T2>`와 같이 여러 자료형을 열거할 수 있으며 `template<int N>`형태의 상수와 `template<typename T, typename Allocator = std::allocator<T>>`와 같이 기본값을 사용할 수 있습니다.

템플릿 함수로 정의 예는 다음과 같습니다.
```
template <typename T>
T add(T& x, T& y)
{
    return x + y;
}

template <typename T1, typename T2> T1 fnDivid(const T2& a, const T2& b)
{
    return static_cast<T1>(a) / static_cast<T2>(b);
}
```

구체화하는 과정은 다음과 같습니다.

1. 컴파일러는 함수를 호출하는 문장을 컴파일 시 함수 정의를 찾습니다.
2. 템플릿으로 선언된 함수 정의를 발견하고 구체화 합니다.
3. 구체화: 함수 호출 `add(a, b);` 문의 파라미터 `a, b`의 자료형이 `int`면 템플릿의 일반 자료형 `T`에 `int`를 대입하고, 구체화된 `int add(int& x, int& y) {...}`코드를 만들어 냅니다.
4. 구체체화된 함수의 소스코드를 컴파일하고 함수를 실행합니다.

함수 템플릿은 컴파일되지도 호출되지 않는 함수의 틀입니다. 템플릿 역할은 제너릭(generic)함수를 선언하고 컴파일 시점에 구체화하기 위한 틀을 만드는 것입니다.

간단하게 컴파일러는 템플릿으로 정의된 함수를 호출하게 되면, 호출시 함수 정의를 찾고 구체화 합니다. 그 다음 호출 시 이미 구체화된 함수를 호출할 뿐 새로 함수를 만들지 않습니다. 즉 함수는 자료형 당 하나씩만 만들어집니다. \
컴파일 시 함수를 생성하기 때문에 컴파일 속도는 느려지나 실행속도가 느려지진 않습니다.

장점은 다음과 같습니다.
+ 템플릿은 함수의 작성이 쉽고 함수 코드의 재사용이 가능합니다.
+ 소프트웨어의 생산성과 유연성을 높입니다.

단점은 다음과 같습니다.
+ 템플릿이 지원되지 않는 컴파일러가 있어 코드의 다른 머신으로의 포팅에 취약합니다.
+ 템플릿 관련 컴파일 오류 메시지 지원이 약해 디버깅에 어려움이 있을 수 있습니다.

# 람다 표현(Lambda exmpression), 람다 함수(Lambda function)

C++ 11 표준에서 만들어진 것으로 다른 곳에 전달될 수 있는 함수 개체입니다. 람다 표현은 익명 함수라고도 하며 보통 다른 함수의 인자로 사용됩니다.

함수 객체보다 람다 표현을 사용하는 이유는 코딩이 간단해진다는 점과 코드의 가독성이 높다는 장점을 가지기 때문입니다. \
람다표현을 이용하면 함수가 필요한 곳에 간단히 함수를 전달할 수 있습니다. 특히 함수가 한번만 사용되고 함수의 길이가 짧은 경우에 유용합니다. \
알고리즘 또는 비동기 함수에 전달되는 몇 줄의 코드를 캡슐화하는데 사용됩니다.

표현 구문은 다음과 같습니다.

<img src= https://learn.microsoft.com/ko-kr/cpp/cpp/media/lambdaexpsyntax.png width="50%" height="50%" title="함수 호출" alt="함수 호출"></img>

1. 캡쳐 블록 (람다 소개자라고도 함) \
캡쳐 블록은 람다에 호출되는 스코프 범위에서 존재하는 변수들을 캡쳐 할 수 있습니다. 대상을 값의 복사(call by value)로 캡쳐 할 것인지 참조(call by reference)로 캡쳐할 것인지 설정 할 수 있습니다. \
모든 변수의 값을 복사 할 때는 [=] 참조를 할 때는 [&]를 사용합니다. 복사 시 복사한 변수에 대입을 하려 하는건 불가능 합니다.(rvalue) \
[=, &변수1, &변수2] 이런 식으로 전체 외부 변수를 복사 하되, 일부 변수만 참조로 가져올 수 있습니다. 반대로 모든 변수를 참조로 가져오고, 일부 변수만 복사로 가지고 올 수 도 있습니다. \
[this] 클래스 멤버 함수인 경우 자기 자신을 전달합니다. [=]로도 전달이 됩니다. \
static이나 전역변수는 따로 정의하지 않아도 접근이 가능합니다. \
C++ 14에서는 스코프 범위에 해당 변수가 없어도 캡쳐 절에서 새 변수를 도입하고 초기화 할 수 있습니다. 이 기능을 사용하면 이동 전용 변수(unique_ptr)을 캡쳐해서 사용 할 수 있습니다.

2. 매개 변수 목록 (람다 선언자라고도 함) \
매개 변수 목록에선 일반적으로 함수의 매개 변수와 비슷합니다. C++14부터는 auto키워드를 지정 할 수 있습니다. 이렇게 하면 함수 호출을 템플릿으로 만들도록 컴파일러에게 알립니다.

3. mutable 키워드 \
mutable 키워드는 값을 복사해 온 변수를 람다 함수 내에서만 값이 바뀔 수 있게 해주는 키워드입니다. 람다 함수 바디를 벗어난 외부에선 값이 바뀌는 것이 아닙니다.

4. 익셉션 목록 \
람다 표현식에서 throw 할 수 있는 익셉션의 종류를 지정할 수 있습니다.

5. 리턴 타입 \
C++ 14부터 지정 안하면 return 자료형을 보고 컴파일러가 지정합니다. \
void일 경우 화살표와 함께 생략 할 수 있습니다.

6. 람다 함수 바디 \
실질적으로 수행 할 구문입니다.
독립적으로 람다를 만드는 경우 `{ }` 뒤에 ;(세미콜론)을 잊지 않도록 주의해야 합니다.

2번부터 5번까지는 생략이 가능합니다.

람다에 의해 만들어진 실행 시점의 객체를 클로저(closure)라고 합니다.

기본 사용법입니다.
```
[] { cout << " 인자 없음 " << endl; };                      // 매개변수 없는 람다 표현식

[] (int a, int b, int c) { cout << a << b << c << endl; };  // 매개변수 있는 람다 표현식

[] { return 200; };                                         // 매개변수 없고 반환 있는 람다

[] (int a, int b) { return a * b; } ;                       // 매개변수 있고 반환 있는 람다
```