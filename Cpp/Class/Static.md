# 정적 클래스, 정적 맴버변수, 정적 멤버함수, 정적 상수

### 정적 클래스

클래스도 static 키워드는 클래스 객체에서도 똑같이 동작한다. static으로 선언된 객체 또한 정적 저장 영역에 저장되어 프로그램이 끝날 때까지 유지된다.

```
#include <iostream>

class Rect
{
  int width, height;

  public:
  Rect()
  {
    std::cout << "constructor" << std::endl;
  }

  ~Rect()
  {
    std::cout << "destructor" << std::endl;
  }
}

void abc()
{
  static Rect object;
}

main()
{
  if (true)
  {
    abc();
  }

  std::cout << "END" << std::endl;
  return 0;
}
```

```
Output : 
constructor
END
destructor
```

if문이 끝날 때 소멸자가 호출되지 않고 main()함수가 끝나 프로그램이 끝날 때 소멸자가 호출 된다.

### 정적 멤버변수

클래스로부터 객체가 생성되면 선언된 일반적인 멤버는 "객체 단위의 멤버"로 객체들 마다 각기 다른 값을 가질 수 있는 독립된 변수지만, 정적 멤버 변수는 객체마다 독립적으로 변수가 선언되는 것이 아니라 클래스에 하나의 변수만 할당되고 생성된 객체들의 정적 멤버는 할당된 저장공간을 공유한다.

정적 멤버 변수는 모든 객체가 공유해야 하므로 프로그램 전체 영역에서 메모리가 유지되야 하고, 따라서 전역 범위에서 정의 및 초기화를 해주어야 한다. \
main 함수는 물론 생성자 안에서도 초기화 할 수 없다.

정적 멤버 변수는 클래스 내에서 선언만이 가능하며 정의는 불가능하다.

헤더 파일과 .cpp 파일로 분리할 때, 정적 멤버변수는 반드시.cpp파일에서 초기화해야한다. 여러 곳에서 헤더 파일을 include할 때 마다 여러번 정의 및 초기화 하는게 될테니 헤더 파일에선 불가능하다.

```
자료형이름 클래스이름::정적멤버변수이름 = 초기화 할 값
```

private 접근 지정자를 통해 선언된 정적 멤버변수도 클래스 외부에서 정의가 가능하다.


다음 코드는 정적 멤버 변수를 가지는 예이다.

```
class Rect
{
  int width, height;
  static int count;

public:
  Rect() {count++;}
  ~Rect() {count--;}
  int getNum() {return count;}
};

int Rect::count = 0;

int main()
{			  // 지역범위 1
	Rect r1, r2;

	cout << "(1)# of Rect: " << r1.getNum() << endl;

	{         // 지역범위 2
		Rect r3;  // 지역범위 2에서 유효한 객체 (r1, r2, r3)
		cout << "(2)# of Rect: " << r3.getNum() << endl;
	}

	// 지역범위 1에서 유효한 객체 (r1, r2)
	cout << "(3)# of Rect: " << r2.getNum() << endl;
	
	return 0;
}
```

위의 프로그램은 main함수(지역범위1) 내에 지역범위2가 존재하는 경우를 보인다. 지역범위1에서 클래스 객체 2개가 생성되고, 지역범위2에서 클래스 객체가 1개 생성됐다. 지역범위 2에서만 유요한 객체는 영역을 벗어나면서 소멸자를 호출해 객체는 사라지게 되었다. 그러므로 실행 결과는 다음과 같다.

```
(1)# of Rect: 2
(2)# of Rect: 3
(3)# of Rect: 2
```

### 정적 멤버함수

멤버함수도 정적 멤버함수로 선언 할 수 있다. \
특정 객체에 종속되지 않는 것으로 객체를 생성하지 않고도 호출이 가능하다. 이 경우 객체가 생성되지 않았기 때문에 클래스 이름을 직접 사용한다. 이때 public 접근지정자를 통해 선언되면 접근이 가능해 사용 할 수 있다. \
정적 멤버함수의 특성은 정적 멤버변수의 특성과 같다. \
정적 멤버함수는 객체의 멤버로 존재하는 것이 아니다.

```
class Rect
{
	int width, height;
	static int num;                        // 정적 멤버변수

public:
	Rect() {num++;}
	~Rect() {num--;}
	static int getNum() {return num;}      // 정적 멤버함수
	static int getWidth() {return width;}  // 정적 멤버함수 (접근 오류) 
};
```

위의 프로그램은 두개의 정적 멤버함수가 정의되어 있다. 이 중 getNum() 멤버함수는 정적 멤버변수인 num의 값을 참조하기에 오류가 발생하지 않는다. 그런데 getWidth 멤버함수는 일반 멤버변수인 width 값을 참조한다. 이 경우 객체가 생성되지 않아도 호출 될 수 있어 접근하는 것이 가능하지 않다 그러므로 정적 멤버함수의 정의에서 컴파일 에러가 발생한다. 즉 정적 멤버함수 내에서는 정적 멤버변수와 정적 멤버함수만 호출 할 수 있다.

### 정적 상수

정적 멤버변수로 선언하면 클래스의 모든 객체에서 공유하여 객체별 저장 공간을 별도로 선언하지 않기 때문에 메모리를 절약할 수 있다. \
정적 상수는 'const static'으로 선언하며 초기화 한 후 값을 변경하는 것이 불가능 하기에 선언과 동시에 초기화가 가능하다. 즉 클래스 내에서 초기화가 가능하며 헤더파일 내에서도 초기화가 가능하다.