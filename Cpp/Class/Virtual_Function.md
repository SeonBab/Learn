# 가상 함수(Virtual Function)

가상 함수는 기본 클래스에서 선언되는 멤버 함수로 파생 클래스에서 재정의할 것을 기대하는 함수다. \
생성된 가상함수를 파생 클래스에서 재정의하면 오버라이딩된다.

가상 함수는 오버로딩이 아닌 오버라이딩을 사용한다. 오버로딩과 오버라이딩의 차이점은 다음과 같다. \
동일한 함수명을 가진 함수를 매개변수를 통해 여러개로 정의하는 것이 오버 로딩이다. \
오버라이딩은 오버 로딩과 다르게 동일한 함수명에 원래 정의되었던 내용들이 새롭게 정의된 내용들로 교체된다. \

### 오버라이딩의 예

가상 함수를 사용하지 않은 오버라이딩은 다음과 같다.

```
#include <iostream>

class A
{
public:
    void Print() { std::cout << "A 클래스의 Print() 함수" << std::endl; }
};

class B : public A
{
public:
    void Print() { std::cout << "B 클래스의 Print() 함수" << std::endl; }
};

int main()
{
    B obj_b;

    obj_b.Print();
    std::cout << std::endl;
    obj_b.A::Print();

    return 0;
}
```

위의 출력은 다음과 같을 것이다.

```
B 클래스의 Print() 함수

A 클래스의 Print() 함수
```

위의 경우 오버 라이딩이 잘 적용 됐지만 main()함수를 수정해 다시 출력해보자

```
int main()
{
    A* ptr;
    A obj_a;
    B obj_b;

    ptr = &obj_a;
    ptr->Print();

    std::cout << std::endl;

    ptr = &obj_b;
    ptr->Print();

    return 0;
}
```

위의 출력은 다음과 같을 것이다.

```
A 클래스의 Print() 함수

A 클래스의 Print() 함수
```

`A`클래스에 대한 클래스 포인터 변수를 생성했다. 포인터 변수가 `B`클래스의 객체를 참조하게 됐는데 `B`클래스의 `Print()`함수를 호출하지 않고 `A`클래스의 `Print()`가 호출 됐다. \
위의 경우로 클래스 포인터 변수는 해당 변수의 타입에 해당하는 클래스의 멤버만 호출한다는 것을 확인했다. \
이와 같은 출력을 원하지 않고, 처음 출력 했을 때와 같은 결과를 얻기 위해 사용하는 것이 가상 함수를 사용하는 것이다.

### 가상 함수의 사용

가상 함수로 지정된 함수를 호출 할 땐, 변수가 아닌 참조하는 객체의 타입이 무엇이냐에 따라 호출한다. \
기본 클래스의 포인터나 참조를 사용하여 호출되더라도 파생 클래스의 가상 함수가 호출된다.

`virtual`이라는 예약어를 함수 앞에 붙여 생성할 수 있다. \
선언은 다음과 같다.

```
virtual 멤버함수의원형;
```

가상 함수의 선언에는 몇 가지 규칙이 존재한다.

+ 전역 또는 정적 함수를 `virtual`선언을 할 수 없다.
+ 매개변수가 같아야 오버라이딩을 통해 재정의 된다.
+ 클래스는 가상 함수로 가상 소멸자를 가질 수 있지만 가상 생성자는 가질 수 없다.
+ 가상 함수는 다른 클래스의 친구(friend)함수가 될 수 없다.
+ 예외적인 상황으로 기본 클래스와 파생 클래스의 가상 함수 반환 타입이 다를 수 있다.
+ 가상 함수는 생성자에서 호출하면 안된다.

`virtual` 키워드를 사용해 가상 함수를 선언하면 파생 클래스에서도 자동으로 가상 함수로 지정되고, `virtual` 키워드를 사용하지 않아도 된다.

가상함수가 선언된 클래스의 객체가 생성되면 가상함수 테이블(Virtual Function Table)이 생성된다. \
여기서 테이블은 배열을 뜻하고, 가상 함수 테이블은 함수 포인터 배열이라고 생각해도 된다. \
가상함수 테이블은 가상함수가 호출 될 때 실행할 함수를 연결해주기 위해 사용된다. \
가상함수 테이블은 각 함수의 주소가 기록되고, 각 객체들은 이 테이블을 가리키는 숨겨진포인터(vfptr)을 가진다. 함수가 호출되면 이 테이블을 참조해 해당 함수를 호출한다. \
가상함수 테이블에 동작시 호출할 함수의 목록을 미리 작성해두고 실행 중 객체와 그 객체가 실행하려는 함수 주소를 찾는 방법으로 동작한다. \
이처럼 함수의 호출 과정이 복잡해져 메모리와 실행 속도 측면에 부담을 가지게 된다. 하지만 파생 클래스에서 재정의할 가능성이 있는 함수는 가상 함수로 선언하는 편이 좋다.

### 순수 가상 함수(Pure Virtual Function)

순수 가상 함수는 가상 함수 중 함수의 정의가 이루어지지 않은 함수를 뜻한다. 그러므로 자식 클래스에서 재정의해서 사용해야 하는 메소드를 뜻한다.

선언은 다음과 같다.
```
virtual int func() = 0;
```

클래스 중 순수 가상 함수를 멤버 함수로 가진 클래스를 추상 클래스(Abstract Class)라고 한다. \
추상 클래스는 객체를 생성할 수 없고, 상속을 통해 파생 클래스에서 순수 가상 함수를 오버라이딩 하여 구현해야만 객체를 생성 할 수 있다. \
추상 클래스는 클래스들의 공통적인 속성을 가지고 공통적인 인터페이스를 가지는 일반화된 클래스다. 상속받는 구체적인 클래스에서 공통적인 인터페이스를 구체적으로 구성한다. \
추상 클래스는 객체를 생성할 수 없으나 추상 클래스 자료형의 포인터와 참조를 사용할 수 있다. \
추상 클래스의 생성자와 소멸자는 다른 멤버 함수를 호출 할 수 있다. \
추상 클래스는 클래스의 멤버 함수 증 순수 가상 함수를 상속받는 클래스에서 구현하는 것을 강제화할 때 사용된다.

추상 클래스는 다음으로 사용 할 수 없다
+ 변수 또는 멤버 데이터
+ 파라미터 자료형
+ 함수의 반환 자료형
+ 명시적 자료형 변환의 자료형

### 가상 소멸자

객체의 소멸 과정에서 포인터 변수의 자료형에 상관없이 모든 소멸자가 호출되어야 하는데 포인터 변수 자료형만의 소멸자가 호출된다. 이 경우 메모리 누수가 발생하므로 해결하기 위해 가상 소멸자를 사용한다.

가상 소멸자는 기존의 소멸자 앞에 `virtual`키워드를 붙인다.
```
virtual ~A();
```

기본 클래스의 소멸자가 `virtual`로 선언되면 상속하는 파생 클래스의 소멸자들도 모두 가상 소멸자로 선언된다. \
가상 소멸자가 호출되면 상속 구조의 맨 아래에 있는 파생 클래스의 소멸자가 대신 호출 되면서 기본 클래스의 소멸자가 순차적으로 호출된다.

### 동적 바인딩(Dynamic Binding)

함수를 호출 할 때 컴파일러는 어느 함수를 호출 할지, 함수 코드가 저장된 위치를 알아야한다. \
함수를 호출하는 코드, 실행될 함수 코드의 관계를 저장해 놓은 것을 바인딩(Binding)이라 한다. 

함수를 호출하는 코드는 컴파일 시점에 실행될 함수의 코드가 저장된 고정된 메모리 주소로 변환하고, 이것을 정적 바인딩(static binding) 또는 초기 바인딩(early binding)이라 한다. \
C++에서는 가상 함수가 아닌 멤버 함수는 모두 정적 바인딩을 한다.

다형성 개념을 구현하기 위해 바인딩이 정적으로 이뤄지면 안된다. \
가상 함수는 프로그램이 실행될 때 대상 객체를 결정하기 때문에 컴파일 시점에 객체를 특정할 수 없고, 그렇기에 함수 호출 코드를 바인딩 할 수 없다. \
그러므로 가상 함수의 호출의 경우 런 타임 시 해당 함수가 실행 될 수 있도록 하는데, 이것을 동적 바인딩(dynamic binding) 또는 지연 바인딩(late binding)이라 한다.

모든 가상 함수가 동적 바인딩을 하진 않는다. \
타입이 분명할 때에는 일반 함수와 같은 정적 바인딩을 한다. \
가상 함수는 기본 클래스 타입의 포인터나 참조를 통해 호출 될 때 동적 바인딩을 하게 된다.

### 가상 함수 테이블(Virtual Function Table, vtbl)

C++에서는 가상 함수의 정의와 동작 방식만을 규정하고 있고, 구현은 컴파일러마다 다르다 \
하지만 컴파일러가 일반적으로 다루는 방식은 가상 함수 테이블(virtual function table)을 이용한다.

C++ 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나씩 추가한다. \
가상 함수를 하나라도 가지는 클래스에서 가상 함수 테이블을 작성하고, 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장된다.

가상 함수를 호출하면, 가상 함수 테이블에 접근해 실행하려는 함수의 주소를 찾아 호출한다. \
함수의 호출 과정이 복잡해지므로, 메모리와 실행 속도 측면에서 부담을 가지게 된다. 하지만 파생 클래스가 재정의할 가능성이 있는 함수는 가상 함수로 선언하는 것이 좋다.