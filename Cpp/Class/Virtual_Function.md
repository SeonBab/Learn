# 가상 함수(Virtual Function)

가상 함수는 기본 클래스에서 선언되는 멤버 함수로 파생 클래스에서 재정의할 것을 기대하는 함수다. \
생성된 가상함수를 파생 클래스에서 재정의하면 오버라이딩된다.

가상 함수는 오버로딩이 아닌 오버라이딩을 사용한다. 오버로딩과 오버라이딩의 차이점은 다음과 같다. \
동일한 함수명을 가진 함수를 매개변수를 통해 여러개로 정의하는 것이 오버 로딩이다. \
오버라이딩은 오버 로딩과 다르게 동일한 함수명에 원래 정의되었던 내용들이 새롭게 정의된 내용들로 교체된다. \

### 오버라이딩의 예

가상 함수를 사용하지 않은 오버라이딩은 다음과 같다.

```
#include <iostream>

class A
{
public:
    void Print() { std::cout << "A 클래스의 Print() 함수" << std::endl; }
};

class B : public A
{
public:
    void Print() { std::cout << "B 클래스의 Print() 함수" << std::endl; }
};

int main()
{
    B obj_b;

    obj_b.Print();
    std::cout << std::endl;
    obj_b.A::Print();

    return 0;
}
```

위의 출력은 다음과 같을 것이다.

```
B 클래스의 Print() 함수

A 클래스의 Print() 함수
```

위의 경우 오버 라이딩이 잘 적용 됐지만 main()함수를 수정해 다시 출력해보자

```
int main()
{
    A* ptr;
    A obj_a;
    B obj_b;

    ptr = &obj_a;
    ptr->Print();

    std::cout << std::endl;

    ptr = &obj_b;
    ptr->Print();

    return 0;
}
```

위의 출력은 다음과 같을 것이다.

```
A 클래스의 Print() 함수

A 클래스의 Print() 함수
```

`A`클래스에 대한 클래스 포인터 변수를 생성했다. 포인터 변수가 `B`클래스의 객체를 참조하게 됐는데 `B`클래스의 `Print()`함수를 호출하지 않고 `A`클래스의 `Print()`가 호출 됐다. \
위의 경우로 클래스 포인터 변수는 해당 변수의 타입에 해당하는 클래스의 멤버만 호출한다는 것을 확인했다. \
이와 같은 출력을 원하지 않고, 처음 출력 했을 때와 같은 결과를 얻기 위해 사용하는 것이 가상 함수를 사용하는 것이다.

### 가상 함수의 사용

가상 함수로 지정된 함수를 호출 할 땐, 변수가 아닌 참조하는 객체의 타입이 무엇이냐에 따라 호출한다. \
기본 클래스의 포인터나 참조를 사용하여 호출되더라도 파생 클래스의 가상 함수가 호출된다.

`virtual`이라는 예약어를 함수 앞에 붙여 생성할 수 있다. \
선언은 다음과 같다.

```
virtual 멤버함수의원형;
```

가상 함수의 선언에는 몇 가지 규칙이 존재한다.

+ 전역 또는 정적 함수를 `virtual`선언을 할 수 없다.
+ 클래스는 가상 함수로 가상 소멸자를 가질 수 있지만 가상 생성자는 가질 수 없다.
+ 가상 함수는 다른 클래스의 친구(friend)함수가 될 수 없다.
+ 예외적인 상황으로 기본 클래스와 파생 클래스의 가상 함수 반환 타입이 다를 수 있다.
+ 매개변수가 같아야 오버라이딩을 통해 재정의 된다.

`virtual` 키워드를 사용해 가상 함수를 선언하면 파생 클래스에서도 자동으로 가상 함수로 지정되고, `virtual` 키워드를 사용하지 않아도 된다.

가상함수가 선언된 클래스의 객체가 생성되면 가상함수 테이블(Virtual Function Table)이 생성된다. \
여기서 테이블은 배열을 뜻하고, 가상 함수 테이블은 함수 포인터 배열이라고 생각해도 된다. \
가상함수 테이블은 가상함수가 호출 될 때 실행할 함수를 연결해주기 위해 사용된다. \
가상함수 테이블은 각 함수의 주소가 기록되고, 각 객체들은 이 테이블을 가리키는 숨겨진포인터(vfptr)을 가진다. 함수가 호출되면 이 테이블을 참조해 해당 함수를 호출한다. \
가상함수 테이블에 동작시 호출할 함수의 목록을 미리 작성해두고 실행 중 객체와 그 객체가 실행하려는 함수 주소를 찾는 방법으로 동작한다. \
이처럼 함수의 호출 과정이 복잡해져 메모리와 실행 속도 측면에 부담을 가지게 된다. 하지만 파생 클래스에서 재정의할 가능성이 있는 함수는 가상 함수로 선언하는 편이 좋다.

