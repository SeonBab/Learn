# 연산자(Operators)

## 산술 연산자

이항 연산자로 피연산자가 2개입니다.

향후 연산자 오버로딩을 통해 다른 클래스에 대해 다른 의미의 연산자를 위한 연산자를 정의할 수 있습니다.

|연산자|설명|
|---|---|
|+|왼쪽 항에 오른쪽 항의 값을 더한다.|
|-|왼쪽 항에 오른쪽 항의 값을 뺀다.|
|*|왼쪽 항에 오른쪽 항의 값을 곱한다.|
|/|왼쪽 항을 오른쪽 항의 값으로 나눈다.|
|%|왼쪽 항을 오른쪽 항의 값으로 나눈 나머지|

/ 연산자는 피연산자가 int형일 땐 값 또한 int형으로 소수점을 표현하지 못합니다. 따라서 float이나 double을 사용하면 소수점까지 연산됩니다.

## 대입 연산자(축약형 연산자)

이항 연산자로 피연산자가 2개입니다.

산술 연산자와 반대로 오른쪽 항에서 왼쪽 항으로 대입되고 산술 연산자와결합된 형태도 존재합니다.

|연산자|설명|
|---|---|
|=|왼쪽 항에 오른쪽 항을 대입한다.|
|+=|왼쪽 항에 오른쪽 항을 더한 후 그 값을 왼쪽 항에 대입한다.|
|-=|왼쪽 항에 오른쪽 항을 뺀 후 그 값을 왼쪽 항에 대입한다.|
|*=|왼쪽 항에 오른쪽 항을 곱한 후 그 값을 왼쪽 항에 대입한다.|
|/=|왼쪽 항에 오른쪽 항을 나눈 후 그 값을 왼쪽 항에 대입한다.|
|%=|왼쪽 항에 오른쪽 항을 나눈 후 그 값의 나머지를 왼쪽 항에 대입한다.|

산술 연산의 특별한 상황에 해당하는 연산자입니다. 즉 이미 할당받은 저장공간(변수)에 산술 연산을 수행하고 그 저장공간에 다시 저장하는 특별한 경우에 사용됩니다.

## 관계 연산자(비교 연산자)

이항 연산자로 피연산자가 2개이며 왼쪽에서 오른쪽으로 결합되고 두 개의 피연산자에 대한 관계 연산 결과는 부울 값(참 또는 거짓)입니다.

|연산자|설명|
|---|---|
|==|두 항의 값이 같으면 1을 반환한다.|
|!=|두 항의 값이 다르면 1을 반환한다.|
|>|왼쪽 항이 오른쪽 항보다 크면 1을 반환한다.|
|>=|왼쪽 항이 오른쪽 항 보다 크거나 같으면 1을 반환한다.|
|<|왼쪽 항이 오른쪽 항 보다 작으면 1을 반환한다.|
|<=|왼쪽 항이 오른쪽 항 보다 작거나 같으면 1을 반환한다.|

## 논리 연산자

이항 연산자로 두 개의 피연산자에 대한 논리곱, 논리합, 부정 연산을 하는 것으로 피연산자는 부울 값이고 연산 결과도 부울 값입니다.

피연산자를 앞에서부터 조사하기 때문에 논리 곱의 경우 앞의 피연산자가 false이면 두 번째 피연산자를 확인하지 않고 결과를 flase로 내고 논리 합의 경우는 앞의 피연산자가 true이면 두 번째 피연산자를 확인하지 않고 결과를 true로 냅니다.

|연산자|설명|
|---|---|
|&&|두 항을 비교하여 모두 참인 경우 1을 반환한다.(AND연산)|
|\|\||두 항을 비교하여 둘 중 하나의 항이 참인 경우 1을 반환한다.(OR연산)|
|!|항의 결과가 참이면 0을 거짓이면 1을 반환한다.(NOT))|

## 비트 연산자

비트 단위로 연산을 취하는 것으로 비트 논리 연산자와 시프트(Shift) 연산자가 있습니다.

비트 논리 연산자: 이항 연산자로 각 피연산자의 값을 비트별로 논리 연산을 수행합니다.

|연산자|설명|
|---|---|
|&|두 항의 각 자릿수를 비교해, 비트가 모두 1이면 1을 반환한다.(비트 AND)|
|\||두 항의 각 자릿수를 비교해, 비트 중에서 하나라도 1이면 1을 반환한다.(비트 OR)|
|^|두 항의 각 자릿수를 비교해, 비트가 서로 다를 경우 1을 반환(비트 XOR)|
|~|항의 각 자릿수의 비트가 1일경우 0으로, 0일 경우 1로 반환(비트 NOT, 1의 보수)|
|<<|지정한 수만큼 비트를 왼쪽으로 이동(Left Shift)|
|>>|지정한 수만큼 비트를 오른쪽으로 이동(Right Shift)|

시프트 연산자: 변수에 저장된 데이터를 비트 단위로 이동시키는 연산자로 왼쪽(<<)으로 오른쪽(>>) 으로 지정한 수 만큼 비트 이동을 합니다. 왼쪽으로 이동시킨 후 남는 자리는 2진수 값 0으로 채워집니다. 오른쪽으로 이동시키는 경우는 부호 비트가 0이면 0을 채우고 부호 비트가 1이면 1을 채웁니다.

## 증감 연산자

변수의 값에 1을 더하거나 1을 빼는 연산자로 연산자가 변수 앞에 있는 경우를 "전위 증감"연산자, 변수 뒤에 있는 경우를 "후위 증감"이라 합니다. 전위, 후위의 의미는 다른 연산자와 함께 사용될 때 다른 연산자 보다 먼저 처리 (전위 증감)되는가 후에 처리 (후위 증감) 되는가를 지정합니다.

|연산자|설명|
|---|---|
|++x|피연산자의 값을 1 증가시킨 후에 해당 연산을 진행한다.|
|x++|해당 연산을 진행한 후에 피연산자의 값을 1 증가시킨다.|
|--x|피연산자의 값을 1 감소시킨 후에 해당 연산을 진행한다.|
|x--|먼저 해당 연산을 진행한 후에 피연산자의 값을 1 감소시킨다.|

## 삼항 연산자

유일하게 3개의 피연산자를 가지며, 문법은 아래와 같습니다.

```
조건식? 반환값1 : 반환값2의 형태로 사용합니다.
```

조건식을 판별하여 결과가 참(true)라면 반환값1을 반환하고 거짓(flase)이면 반환값2를 반환합니다. 이때 반환값에는 수식, 함수 호출 등 여러 가지 형태의 명령문이 올 수 있습니다.

if 조건문을 짧게 표현할 수 있는 장점이 있지만, 축약된 형식이기 때문에 가독성을 해치기도합니다. 특히 한 줄에 조건식과 결과값들이 모두 모여있으므로 디버거로 줄 단위 디버깅을 할 때 불편할 수 있습니다. 따라서 가독성을 해치지 않으며 코드가 간결해지는 경우 사용하면 좋습니다.

## 쉼표 연산자

왼쪽에서 오른쪽으로 결합됩니다. 두 식은 쉼표로 구분되며 왼쪽에서 오른쪽으로 계산됩니다. 즉 오른쪽 피연산자는 항상 왼쪽 피연산자가 실행되고, 모든 파생 작용이 완료된 후 실행됩니다.

쉼표가 구분 기호로 사용되는 경우(함수에 대한 실제 인수 또는 집합체 이니셜라이저), 쉼표 연산자와 피연산자는 괄호로 묶어야 합니다.

```
func_one( x, y + 2, z);
func_two( (x--, y + 2), z);
```

func_one에 대한 함수 호출에서 쉼표로 구분된 세 인수 x, y+2, z가 전달됩니다. func_two에 대한 함수 호출에서 괄호는 컴파일러가 첫 번째 쉼표를 순차적 계산 연산자로 해석하도록 합니다. 이 함수 호출은 두 인수를 func_two에 전달합니다. 첫 번째 인수는(x--, y + 2) 식의 값과 형식을 가진 순차적 계산 연산 y + 2의 결과물이며, 두 번째 인수는 z입니다.

## 연산자 우선순위

<table>
<tr>
<th>연산순위</th>
<th>연산자</th>
<th>설명</th>
<th>결합 방향</th>
</tr>
<tr>
<th>1</th>
<td><code>::</code></td>
<td>범위 지정 (scope resolution)</td>
<td rowspan="10">좌 → 우</td>
</tr>
<tr>
<th rowspan="9">2</th>
<td><code>.</code> 또는 <code>-></code></td>
<td>멤버 액세스</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>배열 첨자</td>
</tr>
<tr>
<td><code>()</code></td>
<td>함수 호출</td>
</tr>
<tr>
<td><code>++</code> 또는 <code>--</code></td>
<td>후위 증가와 감소</td>
</tr>
<tr>
<td><code>typeid</code></td>
<td>타입 이름</td>
</tr>
<tr>
<td><code>const_cast</code></td>
<td>상수 타입 변환</td>
</tr>
<tr>
<td><code>dynamic_cast</code></td>
<td>동적 타입 변환</td>
</tr>
<tr>
<td><code>reinterpret_cast</code></td>
<td>재해석 타입 변환</td>
</tr>
<tr>
<td><code>static_cast</code></td>
<td>정적 타입 변환</td>
</tr>
<tr>
<td rowspan="11">3</td>
<td><code>sizeof</code></td>
<td>개체 또는 타입의 크기</td>
<td rowspan="11">우 → 좌</td>
</tr>
<tr>
<td><code>++</code> 또는 <code>--</code></td>
<td>전위 증가와 감소</td>
</tr>
<tr>
<td><code>!</code> 또는 <code>~</code></td>
<td>논리 NOT, 비트 NOT</td>
</tr>
<tr>
<td><code>-</code> 또는 <code>+</code></td>
<td>음의 부호, 양의 부호<td>
</tr>
<tr>
<td><code>&</code></td>
<td>주소값</td>
</tr>
<tr>
<td><code>*</code></td>
<td>역참조</td>
</tr>
<tr>
<td><code>new</code> 또는 <code>new[]</code></td>
<td>동적 메모리 할당</td>
</tr>
<tr>
<td><code>delete</code> 또는 <code>delete[]</code></td>
<td>동적 메모리 해제</td>
</tr>
<tr>
<td><code>(type)</code></td>
<td>타입 캐스트</td>
</tr>
<tr>
<td><code></code></td>
<td></td>
</tr>
</table>