# 포인터(Pointers)

정의된 자료형의 메모리 주소를 저장하는 변수입니다.

포인터 자료형은 메모리 주소를 저장하는 구조의 독립된 자료형입니다. 포인터 자료형으로 정의한 변수가 포인터 변수이고 일반적으로는 포인터라고 합니다. `DataType* pData;`에서 `DataType*`는 포인터 자료형(type of pointer)이고 `pData`는 포인터(variable of pointer)입니다. `pData`는 DataType으로 만들어진 자료가 저장되어 있는 메모리 주소를 저장하고, 연산자(*, ->, --, ++, +, -, [] 등)를 사용할 수 있습니다.

포인터라는 단어 사용이 포인터 자료형과 포인터 변수, 두 가지를 명확하게 구분하지 않고 중복된 의미로 사용하는 경우가 많습니다.

# 메모리(Memory)

운영시스템(OS, operationg system) 기반하에 실행되는 모든 프로그램은 프로세스 단위로 관리 되고 가상 메모리(virtual memory)를 사용합니다. OS가 각 프로그램에 동일한 가상 주소 공간(virtual address space)을 제공하고 관리는 OS가 합니다. 할당해주는 메모리 공간은 대표적으로 코드(Code), 데이터(Data), 스택(Stack), 힙(Heap)의 네 영역으로 구성됩니다.

1. 코드(code) \
실행할 프로그램의 코드가 저장되는 영역으로 텍스트영역이라고도 부릅니다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
2. 데이터(Data) \
메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다. \
프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.
3. 스택(stack) \
함수의 호출과 관계되는 지역 변수와 매갭녀수가 저장되는 영역입니다. \
함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다. \
스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다. \
푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다. 이러한 스택은 후입선출(LIFO, Last-In First-Out)방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다. \
메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.
4. 힙(heap) \
사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다. \
메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

컴퓨터 하드웨어를 구성하는 RAM(Random Access Memory)이 여기서 이야기하는 메모리에 해당하는 것으로 컴퓨터에서 여러 애플리케이션을 수행하는데 필요합니다. \
메모리에서 저장공간(위치)을 구별하기 위해 주소(address)라는 용어가 사용됩니다. 일반적인 집 주소, 메일 주소 같은 개념으로 메모리의 주소는 메모리의 저장 장소를 구별하는데 사용됩니다. \
컴퓨터 메모리의 구별은 바이트 단위로 이루어지며, 저장되는 데이터는 한 바이트마다 서로 다른 주소 값을 가집니다.

# 주소(adress)

데이터의 주소값이란 해당 데이터가 저장된 메모리의 시작 주소를 의미합니다. C++ 에서는 이러한 주소값을 1바이트 크기의 메모리 공간으로 나눠 이해할 수 있습니다. \
예를 들어, int형 데이터는 4바이트의 크기를 가지지만 int형 데이터의 주소값은 시작 주소 1바이트만을 가리키게 됩니다.

<img src= https://user-images.githubusercontent.com/112116885/226130007-2a68a6fd-ca9b-408c-93d4-4baff81b17ae.png width="50%" height="50%" title="주소" alt="주소"></img>

# 포인터 변수 선언

주소를 저장하는 저장공간을 할당하기 위해서는 일반 변수와 같이 포인터 변수가 선언되어야 합니다. 포인터 변수 선언은 일반 변수 선언과 구별하기 위해 자료형과 변수명 사이에 `*` 기호를 사용합니다. 서언할 때 자료형을 함께 명시하는 이유는 포인터 변수에 저장된 주소로부터 자료형에 해당되는 바이트 수 만큼 저장공간을 참조해야하기 때문입니다.

```
<자료형>* <변수이름>
int * ptr;
```

다음 코드는 `int`형 일반 변수 `n`과 포인터 변수 `ptr`을 선언한 후, 포인터 변수 `ptr`에 일반 변수 `n`을 위해 할당된 4바이트의 저장공간중 첫 주소가 저장됩니다. `int`형 포인트 변수는 `int`형의 데이터가 저장된 저장공간의 주소만을 저장해야 합니다. `char형`의 저장공간의 주소를 저장하기 위해서는 `char`형 포인터 변수를 선언하여야 합니다.
```
타입* 포인터이름 = &변수이름;
타입* 포인터이름 = &주소값;

int n;
int* ptr;
ptr = &n;
```

다음과같이 저장됩니다.

<img src= https://user-images.githubusercontent.com/112116885/226208753-6a728ba0-2bf3-48aa-8961-7e40c6571844.png width="50%" height="50%" title="주소" alt="주소"></img>

+ 포인터와 연관되어 사용되는 연산자입니다.
1. 주소 연산자(&)
    + 변수의 이름 앞에 사용하여, 해당 변수의 주소값을 반환합니다.
    + 일반 변수 및 포인터 변수가 피연산자로 쓰입니다.
    + 앰퍼샌드(Ampersand)라는 이름을 가지고 있습니다.

2. 참조 연산자(*)
    + 포인터의 이름이나 주소 앞에 사용하여, 포인터에 저장된 주소를 접근해 저장되어 있는 값을 반환합니다.
    + 포인터 변수가 피연산자로 쓰입니다.
    + 사용하는 위치에 따라 다양한 용도로 사용됩니다. 곱셈, 포인터 선언시, 메모리에 접근 할 때에 사용됩니다.
    + 아스테리스크(Asterisk)라는 이름을 가지고 있으며 영어권 프로그래머는 줄여서 star라고도 합니다.

+ 여러 개의 포인터 변수를 선언할 때는 다음과 같이 작성하여야 합니다.

```
int *p, *q, *r; // p, q, r은 모두 포인터 변수
int* p, q, r;   // p는 포인터 변수, q, r은 일반 변수
```

```
char* pc;           // char형의 데이터가 저장된 메모리 주소를 저장하기 위한 포인터 변수
int* pi;            // int형의 데이터가 저장된 메모리 주소를 저장하기 위한 포인터 변수
float* pf;          // float형의 데이터가 저장된 메모리 주소를 저장하기 위한 포인터 변수
double pd;          // double형의 데이터가 저장된 메모리 주소를 저장하기 위한 포인터 변수
void* p;            // 메모리에 저장된 데이터에 관계없이 주소를 저장할 수 있는 포인터 변수
Car pobj;           // Car 클래스의 객체가 저장된 메모리 주소를 저장하기 위한 포인터 변수
void (*f)(double);  // 함수 포인터(매개 변수가 더블인 반환 자료형이 없는 함수 주소)
```

위의 void* p는 자료형이 규정되어 있지 않는 것으로 저장된 데이터의 자료형에 따라 다른 자료형의 포인터 변수에 대입 할 수 있습니다.

```
pf = (float *)p;
```

`*`를 여러개 사용해 `int** pptr`로 정의된 ptr의 자료형은 `int**`이며 `int*`로 정의된 변수(포인터)의 주소를 저장할 수 있습니다. 

```
int x = 7;
int* ptr = &x;
int** pptr = &ptr;
```

<img src= https://user-images.githubusercontent.com/112116885/226454501-0c9fc3e2-3fca-47fa-a0f4-bda9d1581437.png width="50%" height="50%" title="주소" alt="주소"></img>

# 간접 참조 연산자, 역참조 연산자(*)

포인터 변수에 저장된 메모리 주소에 저장된 값을 읽거나 변경하는 것이 가능합니다. 포인터 변수 `ptr`에 저장된 데이터 값을 얻기 위해서는 `*`연산자를 다음과 같이 포인터 변수 `ptr`앞에 붙여서 `*ptr`과 같이 작성하면 `ptr`변수에 저장된 주소 값의 저장된 데이터 값을 뜻합니다. `*`연산자는 포인터 변수를 통해 데이터를 간접 참조(deferencing, indirection), 역참조 한다고 합니다.

변수 선언 시 사용하는 `*`은 연산자가 아니라 선언하는 변수가 일반 변수가 아닌 포인터 변수라는 것을 명시하기 위해 사용하는 기호입니다. \
포인터 변수가 선언된 후 포인터 변수 앞에 사용되는 `*`는 기호가 아니라 간접 참조 연산자입니다.

`*`연산자는 단항 연산자로 괄호 다음으로 높은 우선순위를 가져 다른 연산자보다 먼저 실행됩니다.

# 포인터 연산

포인터 변수 역시 변수이므로 연산을 수행할 수 있는데, 값을 증가시키거나 감소시키는 등의 제한된 연산만을 할 수 있습니다.

다음과 같은 규칙들이 있습니다.

1. 곱셈, 나눗셈은 불가능 합니다.
2. 뺄셈은 두 포인터 사이의 상대적 거리를 나타냅니다.
3. 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않습니다.
4. 포인터끼리 대입하거나 비교할 수 있습니다.

포인터 연산 후 각각의 포인터가 가리키고 있는 주소는 포인터의 타입에 따라 달라집니다. 그 증가 혹은 감소 폭은 포인터가 가리키는 변수 타입의 크기와 같습니다.

<img src= https://user-images.githubusercontent.com/112116885/227011531-aba7bc5f-e854-437d-a87c-e8848d79e20c.png width="50%" height="50%" title="주소" alt="주소"></img>

예를 들어 int형 포인터의 증가폭은 int형 타입의 크기인 4바이트만큼 증가하게 됩니다. 이 법칙은 포인터의 뺄셈도 같습니다.

포인터 변수의 메모리 크기는 CPU에 따라 결정됩니다. 32비트 CPU에서는 1워드(word)의 크기가 4바이트이므로, 포인터 변수의 크기 또한 4바이트가 됩니다.

컴파일러로 컴파일 할 때 크기까지 직접 명시할 수 있으며, 포인터 변수의 크기는 CPU의 종류와 컴파일할 때 사용된 컴파일러의 정책에 따라서 달라질 수 있습니다.

워드(word)란 CPU가 한 번에 처리할 수 있는 데이터의 크기입니다. 1바이트는 32비트 시스템에서는 32비트 / 8비트 = 4바이트가 1워드(word)로 처리됩니다. 64비트 시스템에서는 8바이트가 1워드(word)로 처리됩니다.

즉 포인터에 증가 연산자를 적용하였을 경우 증가되는 값은 타입의 크기만큼 증가해 char형에선 1바이트, short형에선 2바이트, int와 float형에선 4바이트씩, double형이면 8씩 증가합니다.

# 포인터와 배열