# 구조체(Structure Type)
배열이 같은 타입의 변수 집합이라면, 구조체는 하나 이상의 변수를 그룹 지어서 새로운 자료형을 정의하는 것이다.

구조체를 구성하는 변수를 구조체의 멤버(member) 또는 멤버 변수(member variable)라고 한다.

# 구조체의 정의와 선언

```
struct 구조체이름
{
    멤버변수1의타입 멤버변수1의이름;
    멤버변수2의타입 멤버변수2의이름;
    ...
};
```

다음은 book이라는 이름의 구조체를 정의하는 그림이다.

<img src= https://user-images.githubusercontent.com/112116885/278186612-33b2c16e-f217-4943-90b2-878c95fb65f1.png width="50%" height="50%" title="구조체" alt="구조체"></img>

다음과같이 정의한 구조체는 아직 메모리에 할당되지 않은 상태이다.

구조체의 선언 끝에 세미콜론을 잊기 쉬워 자주 실수 하는 것 중 하나이다.

정의된 구조체 타입은 다음과 같이 구조체 변수로 선언하여 사용할 수 있다.

```
struct 구조체이름 구조체변수이름;

struct book my_book;
```

구조체의 정의와 구조체 변수의 선언을 동시에 할 수 도 있다.
```
struct 구조체이름
{
    멤버변수1의타입 멤버변수1의이름;
    멤버변수2의타입 멤버변수2의이름;
    ...
} 구조체변수이름;

struct book
{
    char title[30];
    char author[30];
    int price;
} my_book;
```

typedef 키워드를 사용해 새로운 이름을 선언하는 방법은 다음과 같다.

```
typedef struct 구조체이름 구조체의새로운이름;

typedef struct book TEXTBOOK;
```

구조체의 정의와 typedef 선언을 동시에 할 수도 있다.
동시에 할 때에는 구조체의 이름을 생략할 수 있다.

```
typedef struct 구조체이름
{
    멤버변수1의타입 멤버변수1의이름;
    멤버변수2의타입 멤버변수2의이름;
    ...
} 구조체의새로운이름;

typedef struct {
    char title[30];
    char author[30];
    int price;
} TEXTBOOK;
```

# 구조체 멤버로의 접근 방법과 초기화

구조체 멤버로 접근하려고 할 때에는 멤버 액세스 연산자(.)를 사용해야 하며, 초기화할 때에는 멤버 연산자(.)와 유니폼 초기화({})를 사용한다.

구조체에서 구조체 멤버로의 접근 방법은 다음과 같다.

```
구조체변수이름.멤버변수이름

my_book.author
```

구조체의 주소값과 구조체의 첫 번째 멤버 변수의 주소값은 언제나 같다.

구조체 변수의 초기화 방법은 다음과 같다.

```
구조체변수이름 = { 멤버변수1초깃값, 멤버변수2초깃값2, ...};

my_book = { "김선국의 Learn", "홍길동" };
```

구조체 정의에서 멤버 변수가 정의된 순서에 따라 차례대로 초깃값이 설정되며, 초기화 하지 않은 멤버 변수는 기본값인 0으로 초기화된다.

# 구조체 배열 선언

C 언어에서 배열의 요소가 될 수 있는 타입에는 제한이 없으며, 구조체 역시 배열의 한 요소가 될 수 있다.

다른 타입의 배열을 선언하는 방법과 같으며, 각 배열 요소로 접근하는 방법도 일반 배열의 접근 방법과 같다.

다음 예제는 구조체 배열의 선언 및 초기화를 보여주는 예제는 다음과 같다.
```
struct book text_book[3] =
{
    {"국어", "홍길동", 15000},
    {"영어", "이순신", 18000},
    {"수학1", "강감찬", 10000}
};
```

위의 예제와 같이 구조체 배열은 2차원 배열의 초기화 방법과 같은 방법으로 초기화 할 수 있다.
또한, 멤버 액세스 연산자(.)를 사용하여 각 배열 요소의 멤버에 접근할 수 있다.

다음 그림은 위의 예제에서 사용된 구조체 배열 text_book의 메모리 상태를 보여준다.

<img src= https://user-images.githubusercontent.com/112116885/278850141-2591ab6a-0547-4e35-b90f-82f28e474dbb.png width="50%" height="50%" title="구조체" alt="구조체"></img>

# 구조체를 가리키는 포인터

구조체 변수를 가리키는 구조체 포인터는 다음과 같이 선언한다.

```
struct 구조체이름* 구조체포인터이름;

struct book* ptr_my_book;
```

배열의 경우와 달리 구조체의 이름은 구조체를 가리키는 주소가 아니다.
따라서 포인터에 할당할 때에는 반드시 주소 연산자(&)를 사용해야한다.

구조체 포인터를 이용하여 구조체의 멤버에 접근하는 방법에는 다음과 같이 두 가지 방법이 있다.

1. 참조 연산자(*)를 이용하는 방법
2. 화살표 연산자를(->)를 이용하는 방법

참조 연산자(*)를 이용하는 방법은 다음과 같다.
```
(*구조체포인터).멤버변수이름

(*ptr_my_book).author
```

참조 연산자(*)는 멤버 연산자(.)보다 연산자 우선순위가 낮으므로 반드시 괄호(())를 사용해야한다.

화살표 연산자(->)를 이용하는 방법은 다음과 같다.
```
구조체포인터->멤버변수이름

ptr_my_book->author
```

화살표 연산자의 앞쪽에는 구조체 포인터를, 뒤쪽에는 접근하고자하는 구조체의 멤버 변수 이름을 사용하면 된다.

# 바이트 패딩(byte padding)
구조체를 메모리에 할당할 때 컴파일러는 프로그램의 속도 향상을 위해 바이트 패딩(byte padding)이라는 규칙을 이용한다.
구조체는 다양한 크기의 타입을 멤버 변수로 가질 수 있는 타입이다.
하지만 컴파일러는 메모리의 접근을 쉽게 하기 위해 메모리 크기가 큰 멤버 변수를 기준으로 멤버 변수의 메모리 크기를 맞추게 된다.
이것을 바이트 패딩이라고 하며, 이때 추가되는 바이트를 패딩 바이트(padding byte)라고 한다.

<img src= https://user-images.githubusercontent.com/112116885/278850450-fcaeabb8-890d-4310-bc9e-12bf14b6eda2.png width="50%" height="50%" title="패딩" alt="패딩"></img>

예제에서는 크기가 가장 큰 double형 타입의 크기인 8바이트가 기준이 된다.
맨 처음 char형 멤버 변수를 위해 8바이트가 할당되며, 할당되는 1바이트를 제외한 7바이트가 남게 된다.
그다음 int형 멤버 변수는 남은 7바이트보다 작으므로, 그대로 7바이트 중 4바이트를 할당하고 3바이트가 남게 된다.
마지막 double형 멤버 변수는 8바이트인데 남은 공간이 3바이트뿐이므로 다시 8바이트를 할당받는다.
따라서 이 구조체의 크기는 총 16바이트가 되며, 그중에서 패딩 바이트(padding byte)는 3바이트가 된다.

# 중첩된 구조체(Nested structs)

구조체는 다른 구조체를 포함할 수 있다.

```
struct Author
{
    char name[30];
    int age;
};

struct Book
{
    Author bookAuthor;
    char title[30];
    int price;
};

Book myBook;
```

위에서 Author의 age를 접근하고싶다면 멤버 선택 연산자(.)를 두 번 사용하면 된다.

```
myBook.bookAuthor.age
```

중첩된 구조체에 대해 중첩된 초기화 목록을 사용할 수 있다.

```
Book myBook = {{ "홍길동", 30 }, "국어", 15000 };
```