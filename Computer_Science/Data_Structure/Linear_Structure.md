# 선형 구조(Linear Structure)

데이터들이 선 형태로 순차적으로 나열되어있는 형태로 자료들간 전, 후 관계가 1:1 관계를 가진다.

### 순차 리스트(Sequential List)

메모리에 동일한 자료형의 데이터들이 같은 크기로 연속된 위치에 나열된 집합이다. \
논리적 저장 순서와 물리적 저장 순서가 일치해 임의 접근(Random Access)이 가능하다. \
임의 접근은 직접 접근으로도 부르는데, 자료를 순차적으로 조사하지않고도 저장장치로부터 특정 부분을 직접 검색 할 수 있는 접근 방법이다. 예를 들면 인덱스를 활용해 배열의 N번째에 접근하는 경우가 임의 접근을 한 경우다. \
순차 리스트의 임의 접근은 데이터가 어디에 위치해있든 데이터를 접근하는 비용은 같다.

공간 지역성이 좋아 Cache Hit Rate가 높다. \
추가적으로 소모되는 메모리 양(오버헤드)가 거의 없다. \
자료를 저장할 메모리를 미리 확보해야 한다.

순차 리스트는 크게 정적(static) 배열과 동적(dynamic)배열이 있다.

정적 배열은 정해진 크기 만큼만 데이터를 담을 수 있다. \
메모리를 먼저 할당 받아 크기가 고정되어있기 때문에 크기를 변경하기 어려운 정적인 자료 구조다. \
메모리가 연속적으로 있어야하기 때문에 메모리의 낭비가 발생할 수 있다.

위의 배열이 가진 단점을 보완한 것이 동적 배열이다. \
동적 배열은 크기를 자유자재로 늘리거나 줄일 수 있다.

정적 배열과 동적 배열은 다양한 연산에서 동일한 성능을 보인다.

시간복잡도
+ 탐색 : O(1)
    + 인덱스 번호가 있기 때문에 매우 빠르게 탐색이 가능하다.
+ 추가 : O(N)
    + 추가되는 데이터 위치 이후에 있는 모든 데이터를 인덱스 값들을 모두 밀어내야 하므로 O(N)의 시간 복잡도를 가진다.
    + 동적 배열이 더 이상 공간이 없을 때 추가하려하면 새로운 배열을 생성해 기존 배열의 값을 복사하고 추가하므로 O(N)이다.
    + 추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면 O(1)의 시간 복잡도를 가진다.
+ 삭제 : O(N)
    + 삭제하려는 데이터의 위치이후의 인덱스 값들을 모두 앞으로 당겨와야 하므로 O(N)의 시간복잡도를 가진다.
    + 삭제하려는 데이터의 위치가 맨 뒤라면 O(1)의 시간복잡도를 가진다.

### 연결 리스트(Linked List)

연결 리스트는 순차 리스트와 다르게 자료들이 연속된 위치에 나열되어있지 않다. \
물리적 저장 순서와 위치에 상관없이, 링크에 의해 논리적인 순서를 표현하는 자료구조다. \
실제로 데이터가 메모리 상에 연속적으로 있지 않고, 메모리 주소는 랜덤이다. \

노드라는 각각의 독립된 공간을 사용해 데이터를 남는다. \
노드는 실제 데이터가 저장되는 공간인 데이터 필드와 다음 노드의 주소 값을 가진 링크 필드로 이뤄져 있다. \
시작하는 노드를 머리(head)라 하고, 맨 끝 노드를 꼬리(tail)라고 한다. \
노드에서 다음 노드로 향하는 주소값을 링크(link) 혹은 포인터(pointer)라고 한다. \

Cache Hit Rate가 낮다.
순차 리스트가 연속된 메모리를 가지며 발생하는 낭비가 연결 리스트에서는 메모리상 연속적인 위치를 가질 필요가 없고 빈공간을 허용하지 않아 메모리의 낭비가 없다.
크기가 가변적이다.

원소의 중간 삽입과 삭제에 있어서 좋은 성능을 보인다. \
다만 n번째 자리를 찾아서 그 자리의 원소를 삽입하거나 삭제한다는 것은 n번째 자리를 찾는다는 연산이 있어 비효율적일 수 있다.

배열의 장점이었던 임의 접근이 불가능하다. \
중간 노드의 연결이 끊어지면 다음 순서의 노드를 찾기 어렵다.

삽입, 삭제, 크기 등 해당 리스트를 사용하기 위해 다양한 속성과 메서드가 존재한다.

시간복잡도
+ 탐색 : O(N)
    + 
+ 추가 : O(N)
    + 
+ 삭제 : O(N)
    + 