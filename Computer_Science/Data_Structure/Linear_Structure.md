# 선형 구조(Linear Structure)

데이터들이 선 형태로 순차적으로 나열되어있는 형태로 자료들간 전, 후 관계가 1:1 관계를 가진다.

## 순차 리스트(Sequential List)

메모리에 동일한 자료형의 데이터들이 같은 크기로 연속된 위치에 나열된 집합이다. \
논리적 저장 순서와 물리적 저장 순서가 일치해 임의 접근(Random Access)이 가능하다. \
임의 접근은 직접 접근으로도 부르는데, 자료를 순차적으로 조사하지않고도 저장장치로부터 특정 부분을 직접 검색 할 수 있는 접근 방법이다. 예를 들면 인덱스를 활용해 배열의 N번째에 접근하는 경우가 임의 접근을 한 경우다. \
순차 리스트의 임의 접근은 데이터가 어디에 위치해있든 데이터를 접근하는 비용은 같다.

공간 지역성이 좋아 Cache Hit Rate가 높다. \
추가적으로 소모되는 메모리 양(오버헤드)가 거의 없다. \
자료를 저장할 메모리를 미리 확보해야 한다.

순차 리스트는 크게 정적(static) 배열과 동적(dynamic)배열이 있다.

정적 배열은 정해진 크기 만큼만 데이터를 담을 수 있다. \
메모리를 먼저 할당 받아 크기가 고정되어있기 때문에 크기를 변경하기 어려운 정적인 자료 구조다. \
메모리가 연속적으로 있어야하기 때문에 메모리의 낭비가 발생할 수 있다.

위의 배열이 가진 단점을 보완한 것이 동적 배열이다. \
동적 배열은 크기를 자유자재로 늘리거나 줄일 수 있다.

정적 배열과 동적 배열은 다양한 연산에서 동일한 성능을 보인다.

시간복잡도
+ 탐색 : O(1)
    + 인덱스 번호가 있기 때문에 매우 빠르게 탐색이 가능하다.
+ 추가 : O(N)
    + 추가되는 데이터 위치 이후에 있는 모든 데이터를 인덱스 값들을 모두 밀어내야 하므로 O(N)의 시간 복잡도를 가진다.
    + 동적 배열이 더 이상 공간이 없을 때 추가하려하면 새로운 배열을 생성해 기존 배열의 값을 복사하고 추가하므로 O(N)이다.
    + 추가하려는 데이터의 위치가 맨 뒤이고 배열에 공간이 남아있다면 O(1)의 시간 복잡도를 가진다.
+ 삭제 : O(N)
    + 삭제하려는 데이터의 위치이후의 인덱스 값들을 모두 앞으로 당겨와야 하므로 O(N)의 시간복잡도를 가진다.
    + 삭제하려는 데이터의 위치가 맨 뒤라면 O(1)의 시간복잡도를 가진다.

## 연결 리스트(Linked List)

연결 리스트는 순차 리스트와 다르게 자료들이 연속된 위치에 나열되어있지 않다. \
물리적 저장 순서와 위치에 상관없이, 링크에 의해 논리적인 순서를 표현하는 자료구조다. \
실제로 데이터가 메모리 상에 연속적으로 있지 않고, 메모리 주소는 랜덤이다.

노드라는 각각의 독립된 공간을 사용해 데이터를 남는다. \
노드는 실제 데이터가 저장되는 공간인 데이터 필드와 다음 노드의 주소 값을 가진 링크 필드로 이뤄져 있다. \
시작하는 노드를 머리(head)라 하고, 맨 끝 노드를 꼬리(tail)라고 한다. \
노드에서 다음 노드로 향하는 주소값을 링크(link) 혹은 포인터(pointer)라고 한다.

Cache Hit Rate가 낮다.
순차 리스트가 연속된 메모리를 가지며 발생하는 낭비가 연결 리스트에서는 메모리상 연속적인 위치를 가질 필요가 없고 빈공간을 허용하지 않아 메모리의 낭비가 없다.
크기가 가변적이다.

원소의 중간 삽입과 삭제에 있어서 좋은 성능을 보인다. \
다만 n번째 자리를 찾아서 그 자리의 원소를 삽입하거나 삭제한다는 것은 n번째 자리를 찾는다는 연산이 있어 비효율적일 수 있다.

배열의 장점이었던 임의 접근이 불가능하다. \
중간 노드의 연결이 끊어지면 다음 순서의 노드를 찾기 어렵다.

삽입, 삭제, 크기 등 해당 리스트를 사용하기 위해 다양한 속성과 메서드가 존재한다.

시간복잡도
+ 탐색 : O(N)
    + N번째 자료에 접근하기 위해 N-1 번째 자료에서 정보를 얻어와야하고, N-1번째는 N-2번째로부터 정보를 얻어와야한다. 결국 1번째 자료부터 N번째 자료까지 타고 가야하므로 O(N)의 시간복잡도를 가진다.
+ 추가 : O(1)
    + 해당 위치의 자료가 가지고 있는 레퍼런스만 바꾸어 주면되므로 O(1)의 시간복잡도를 가진다.
+ 삭제 : O(1)
    + 해당 위치의 자료가 가지고 있는 레퍼런스만 바꾸어 주면되므로 O(1)의 시간복잡도를 가진다.

연결 리스트는 구조에 따라서 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트로 나뉜다.

### 단일 연결 리스트(Singly Linked List)

단일 연결 리스트는 노드의 포인터가 단일 방향으로만 연결 되어있다.

### 이중 연결 리스트(Doubly Linked List)

이중 연결 리스트는 노드의 포인터가 서로 연결되어있다. \
이중 연결 리스트의 노드에선 이전 노드와 다음 노드에 대한 두 개의 링크를 가지는 리스트다. \
두 개의 링크를 가져 양방향으로 검색과 순환이 가능하다.

연속적인 탐색과 액세스가 이뤄져야 하는 경우 탐색 시간이 절약될 수 있다. \
노드의 수가 n인 이중 연결 리스트에서 $\frac{2}{n}$ 보다 작은 순서의 노드는 머리(head)에서부터 탐색하고, $\frac{2}{n}$보다 크거나 같은 순서의 노드는 꼬리(tail)에서부터 탐색하도록 구현해 최대 탐색 시간을 단일 연결 리스트에 비해 반으로 줄일 수 있다.

이전 노드에 대한 링크를 가져야해 메모리를 더 많이 사용한다. \
단일 연결 리스트에 비해 구현이 복잡해진다.

### 원형 연결 리스트(Circualr Linked List)

원형 연결 리스트는 기존의 연결리스트에서 마지막 노드가 첫 노드로 향하게 한 리스트다. \
연결 상태가 원형을 그려 원형 연결 리스트다.

하나의 노드에서 다른 모든 노드로의 접근이 가능하고, 링크를 따라가 자기 자신으로 되돌아 올 수 있다. \
꼬리에 노드를 추가할 경우 머리부터 모든 노드를 거쳐 마지막에 삽입하는 것이 아니라 헤드에서 링크가 마지막 노드를 가리키도록 구성하면 처음과 끝에 적은 비용으로 노드를 삽입 할 수 있다.

## 스택

