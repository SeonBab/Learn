# 분수의 덧셈

## 문제 설명

첫 번째 분수의 분자와 분모를 뜻하는 `numer1`, `denom1`, 두 번째 분수의 분자와 분모를 뜻하는 `numer2`, `denom2`가 매개변수로 주어집니다. 두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.

## 제한사항

0 < `numer1`, `denom1`, `numer2`, `denom2` < 1,000

## 입출력 예

numer1|denom1|numer2|denom2|result
---|---|---|---|---
1|2|3|4|[5, 4]
9|2|1|3|[29, 6]

## 입출력 예 설명

입출력 예 #1

+ 1 / 2 + 3 / 4 = 5 / 4입니다. 따라서 [5, 4]를 return 합니다.

입출력 예 #2

+ 9 / 2 + 1 / 3 = 29 / 6입니다. 따라서 [29, 6]을 return 합니다.

## 제출

최대공약수 찾아서 계산하기
```
std::vector<int> solution(int numer1, int denom1, int numer2, int denom2) {
    std::vector<int> answer;

    // 분자, 분모 계산
    int numer = numer1 * denom2 + numer2 * denom1;
    int denom = denom1 * denom2;

    // 최대공약수를 저장할 변수 생성
    int GCD{};

    // 최대공약수 계산
    for (int i = 1; i <= numer; ++i)    // (int i = std::min(denom, numer); i >= 1; --i)로 수정 가능
    {
        if ((numer % i == 0) && (denom % i == 0))
        {
            GCD = i;    // 주석의 내용으로 수정시 break;를 사용할 수 있다.
        }
    }

    // 약분과 대입
    answer.push_back(numer / GCD);
    answer.push_back(denom / GCD);

    return answer;
}
```

유클리드 호제법으로 최대공약수 찾아서 계산하기
```
#include <vector>
#include <algorithm>

// 최대공약수를 찾아주는 함수
int GetGCD(int a, int b)
{
    int c{};

    std::pair<int, int> r1 = std::minmax(a, b); // if문으로 대체해서 작은 수와 큰 수 찾을 수 있다.

    a = r1.first;   // 작은 수
    b = r1.second;  // 큰 수

    // 유클리드 호제법
    while (a != 0)
    {
        c = b % a;
        b = a;
        a = c;
    }
    
    return b;
}

std::vector<int> solution(int numer1, int denom1, int numer2, int denom2) {
    std::vector<int> answer;

    // 분자, 분모 계산
    int numer = numer1 * denom2 + numer2 * denom1;
    int denom = denom1 * denom2;

    // 최대공약수를 저장할 변수 생성
    int GCD{};

    // 최대공약수 계산
    GCD = GetGCD(numer, denom);

    // 약분과 대입
    answer.push_back(numer / GCD);
    answer.push_back(denom / GCD);

    return answer;
}
```