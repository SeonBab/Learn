# 진료 순서 정하기

## 문제 설명

외과의사 머쓱이는 응급실에 온 환자의 응급도를 기준으로 진료 순서를 정하려고 합니다. 정수 배열 `emergency`가 매개변수로 주어질 때 응급도가 높은 순서대로 진료 순서를 정한 배열을 return하도록 solution 함수를 완성해주세요.

## 제한사항

+ 중복된 원소는 없습니다.
+ 1 ≤ `emergency`의 길이 ≤ 10
+ 1 ≤ `emergency`의 원소 ≤ 100

## 입출력 예

emergency|result
---|---
[3, 76, 24]|[3, 1, 2]
[1, 2, 3, 4, 5, 6, 7]|[7, 6, 5, 4, 3, 2, 1]
[30, 10, 23, 6, 100]|[2, 4, 3, 5, 1]
## 입출력 예 설명

입출력 예 #1

+ `emergency`가 [3, 76, 24]이므로 응급도의 크기 순서대로 번호를 매긴 [3, 1, 2]를 return합니다.
입출력 예 #2

+ `emergency`가 [1, 2, 3, 4, 5, 6, 7]이므로 응급도의 크기 순서대로 번호를 매긴 [7, 6, 5, 4, 3, 2, 1]를 return합니다.
입출력 예 #3

+ `emergency`가 [30, 10, 23, 6, 100]이므로 응급도의 크기 순서대로 번호를 매긴 [2, 4, 3, 5, 1]를 return합니다.

## 제출

반복문을 사용하여 i번과 다른 모든 수를 한번씩 비교하기 위해 j번을 만들고, i번의 수 보다 j번의 수가 더 크면 번호를 1개씩 증가시킨다.
중복된 원소는 없으므로 무조건 크거나 작을 수 만 있기 때문에 if문은 <를 사용했다.

```
#include <vector>

using namespace std;

vector<int> solution(vector<int> emergency) {
    vector<int> answer;

    for (int i = 0; i < emergency.size(); ++i)
    {
        answer.push_back(1);
        
        for(int j = 0; j < emergency.size(); ++j)
        {
            if(emergency[i] < emergency[j])
            {
                ++answer[i];
            }
        }
    }
    return answer;
}
```